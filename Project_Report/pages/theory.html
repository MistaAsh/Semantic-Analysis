<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>CD-Lab-Mini_Project</title>
  <link href="../css/style.css" rel="stylesheet" type="text/css" />
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" data-auto-a11y="true">

  </script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous">

    </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous">

    </script>
  <!-- jQuery library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js">

  </script>
  <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" data-auto-a11y="true">

  </script>
  <!-- Latest compiled JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js">

  </script>
  <!-- Wave diag -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/skins/default.js" type="text/javascript">

  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/wavedrom.min.js" type="text/javascript">

  </script>
</head>

<body>
  <nav class="navbar navbar-expand-md bg-light">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
      <span class="navbar-toggler-icon">
        <i class="fas fa-bars"></i>
      </span>
    </button>
    <!--         <a class="navbar-brand" href="../index.html">Home</a> -->
    <div class="collapse navbar-collapse" id="collapsibleNavbar">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="aim.html">Aim</a>
        </li>
        <li class="nav-item active">
          <a class="nav-link" href="../pages/theory.html">Theory <span class="sr-only">(current)</span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../pages/pre-test.html">Pretest</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../pages/procedure.html">Procedure</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../pages/simulation.html">Simulation</a>
        </li>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../pages/post-test.html">Posttest</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../pages/references.html">References</a>
        </li>
      </ul>
    </div>
  </nav>
  <div class="simscreen" id="calc2-screen">
    <h2 class="simscreen-heading">THEORY</h2>
    <hr>
    <div class="container-fluid">
      <div id="carousel-theory-generic">
        <div>
          <div class="item">
            <div>
              <h3 class="def-heading">Type Expressions</h3>
              <p class="theory">
                Type Expression is an entity in Compiler Design that denotes the type of a language construct. Type Expressions can be of multiple types such as-
                  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - basic types: <i>int, float, double, char</i> 
                  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - formed by applying operators called <i>type constructors</i> to another type expressions 
                  <br> A type constructor applied to a type expression is a type expression. 
                  <br> For example, <b>Array:</b> if T is a type expression then array(I, T) is a type expression denoting the type of an array with elements of type T and index set I.
              </p>
              <hr class="hr-separator">
              <h3 class="def-heading">Type Checking</h3>
              <p class="theory">
                Type Checking in Compiler Design refers to the process of checking for each operation such that they receive the required number of operands of the proper datatype.  
                <br> For example, in the expression: &nbsp; <b><i>A = B * j + d;</i></b>
                <br> * and + are basically int and float data types based operations and if any variable in this expression is of other than int and float then compiler will generate type error.
                <div class="theory-li-container">
                  <li class="theory-li"> Dynamic Type Checking: it is done at runtime and uses the concept of type tag which is stored in each data objects that indicates the type of the object. Languages such as <i>Perl</i> and <i>Prolog</i> follow dynamic type checking. </li>
                  <li class="theory-li"> Static Type Checking: it is done at compile-time. The information for the same is provied by the declaration of language structures. 
                    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - for each operation, the number, order and datatype of the arguments are required.
                    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - for each variable, the name and datatype is required.
                  </li>
                </div>
              </p>
              <figure>
                <img src="../images/type-checker-1.png" alt="type-checker-1" class="theory-image">
                <figcaption>Fig 1: Type Checker </figcaption>
              </figure>
            </div>
          </div>
          <hr class="hr-separator">
          <div class="item">
            <div>
              <h3 class="def-heading">Type Equivalence</h3>
              <p class="theory">
                Type Equivalence is the methodology of defining the equivalence of two types. The different types of equivalence that are essential to be considered are:
                <div class="theory-li">
                  <li class="theory-li-container"> Structural equivalence: Two type expressions are said to be structurally equivalent if and only if, either these are of the same basic types or these are formed by applying the same constructor to the given equivalent types. </li>
                  <li class="theory-li-container"> Name equivalence: two type expressions can be said to be name equivalent if and only if, they are structurally equivalent and the names of the type constructors are the same. </li>
                </div>
              </p>
            </div>
          </div>
          <hr class="hr-separator">
          <div class="item">
            <div>
              <h3 class="def-heading">Type Conversion</h3>
              <p class="theory">
                The type conversion is an operation that takes a data object of one type and creates the equivalent data objects of multiple types. The signature of a type conversion operation is given as
                <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>conversion_op : type1 â†’ type2</i>
                <br> If during type checking, a mismatch appears between the actual type of an argument and the expected type for that operation, then type conversion easily converts the data object implicitly and prevents the error. In some languages such as C, type conversion is a built-in function, which implicitly casts an expression to convert it to the correct type. There are two types of type conversions-
                <div class="theory-li-container">
                  <li class="theory-li">Implicit type conversion (Coercions): The programming languages that enable mixed-mode expressions should describe conventions for implicit operand type conversions. Coercion is defined as an automatic conversion between types. For example in Pascal, if the operands for the addition operation are of integer type and other real types, one of then the integer data object is implicitly changed to type real earlier the addition is implemented. </li>
                  <li class="theory-li">Explicit type conversion: Some languages support few efficiencies for doing explicit conversions, both widening and narrowing. In some cases, warning messages are created when an explicit narrowing conversion results in a meaningful change to the value of the object being modified.</li>
                </div>
              </p>
              <figure>
                <img src="../images/type-conversion-1.jpg" alt="type-conversion-1" class="theory-image">
                <figcaption>Fig 2: Type Conversion hierarchy in C</figcaption>
              </figure>
            </div>
          </div>
        <hr class="hr-separator">
      </div>
    </div>
  </div>
</body>

</html>